---
title: "Flight Delays in the United States, during 2023 - Data Setup and Data Description"
format: docx
---

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# BEGIN READING AND PROCESSING DATA COLUMNS ###########
```

```{r echo=FALSE, warning=FALSE}
# Load the 2% Sample data from a CSV file into a data frame
df <- read.csv("/Users/shreya/Documents/FlightDataAnalysisV3/data/delaysample.csv")
#df <- read.csv("delay2023.csv")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)
```

```{r echo=FALSE, warning=FALSE}
# Review Column Names
#colnames(df)
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Convert Column Names from snake_case to camelCase

# Helper function to convert snake_case to camelCase
toCamelCase <- function(string) {
  # Split the string by underscores and convert to lowercase
  words <- tolower(unlist(strsplit(string, "_")))
  # Capitalize the first letter of each word except the first word
  words[-1] <- sapply(words[-1], function(word) {
    paste(toupper(substr(word, 1, 1)), substr(word, 2, nchar(word)), sep = "")
  })
  # Concatenate the words back together
  return(paste0(words, collapse = ""))
}

# Apply the function to all column names in the dataframe
if (exists("df") && is.data.frame(df)) {  # Check if 'df' exists and is a dataframe
  colnames(df) <- sapply(colnames(df), toCamelCase)
} else {
  cat("Dataframe 'df' does not exist or is not a dataframe.")
}
```

```{r echo=FALSE, warning=FALSE}
# Review Column Names
# colnames(df)
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
####### Canceled and Diverted Flights ######
# Exclude canceled and diverted flights from the dataframe
df <- df %>%
  filter(cancelled == 0 & diverted == 0)

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Time Period Information
# Reformat date using lubridate
library(lubridate)
df$flDate <- as.Date(mdy_hms(df$flDate))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# convert to factor variable: "year", "quarter", "month", "dayOfMonth", "dayOfWeek"
df <- df %>%
  mutate(
    year = factor(year),
    quarter = factor(quarter),
    month = factor(month),
    dayOfMonth = factor(dayOfMonth),
    dayOfWeek = factor(dayOfWeek)
  )
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Ensure month is a factor and set levels starting with January
df$month <- factor(df$month, 
                   levels = 1:12, 
                   labels = c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"))

# Relabel the dayOfWeek factor levels to abbreviated day names
df$dayOfWeek <- factor(df$dayOfWeek, 
                       levels = 1:7, 
                       labels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Add a new column 'weekend' that checks the day of the week
df <- df %>%
  mutate(weekend = factor(if_else(dayOfWeek %in% c("Sat", "Sun"), "Weekend", "Weekday"),
                          levels = c("Weekday", "Weekend")))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Seasonality:  Track departure and arrival time as AM or PM
df <- df %>%
  mutate(
    depTimeAMPM = factor(if_else(depTime < 1200, "AM", "PM"), levels = c("AM", "PM")),
    arrTimeAMPM = factor(if_else(arrTime < 1200, "AM", "PM"), levels = c("AM", "PM"))
  )
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Origin and Destination Airports -- Convert relevant columns to factor variables
df <- df %>%
  mutate(
    origin = factor(origin),
    originCityName = factor(originCityName),
    originStateAbr = factor(originStateAbr),
    originStateNm = factor(originStateNm),
    dest = factor(dest),
    destCityName = factor(destCityName),
    destStateAbr = factor(destStateAbr),
    destStateNm = factor(destStateNm)
  )
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
originAirports <- levels(df$origin)
numOriginAirports <- length(levels(df$origin))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
destAirports <- levels(df$dest)
numDestAirports <- length(levels(df$dest))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Set Airline / Carrier data types as factor variables
df <- df %>%
  mutate(
    mktUniqueCarrier = factor(mktUniqueCarrier),
    opUniqueCarrier = factor(opUniqueCarrier),
    tailNum = factor(tailNum),
    mktCarrierFlNum = factor(mktCarrierFlNum)
  )
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
airlineIATA <- levels(df$mktUniqueCarrier)
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Define the mapping of IATA codes to airline names
#### Note that the variable mktUniqueCarrier in the data records the IATA code of the airline.
airlineNames <- c(
  "AA" = "American Airlines",
  "AS" = "Alaska Airlines",
  "B6" = "JetBlue Airways",
  "DL" = "Delta Air Lines",
  "F9" = "Frontier Airlines",
  "G4" = "Allegiant Air",
  "HA" = "Hawaiian Airlines",
  "NK" = "Spirit Airlines",
  "UA" = "United Airlines",
  "WN" = "Southwest Airlines"
)
# Add a new column 'Airline' to the dataframe and map the 'mktUniqueCarrier' to 'Airline'
df <- df %>%
  mutate(airline = airlineNames[mktUniqueCarrier])
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Define the top 4 airlines
top4Airlines <- c("AA", "DL", "WN", "UA")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Add a new column 'airlineName' to the dataframe
df <- df %>%
  dplyr::mutate(airline = airlineNames[mktUniqueCarrier],
                airlineName = if_else(mktUniqueCarrier %in% top4Airlines, airline, "Other Airlines"))
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
### Number of Flights by Airline (Top 4 and Other Airlines)

# Count the number of flights for each airline name
flightCountsNew <- df %>%
  dplyr::group_by(airlineName) %>%
  dplyr::summarise(noOfFlights = n(), .groups = 'drop') %>%
  dplyr::arrange(desc(noOfFlights))

# Calculate the total number of flights
totalFlightsNew <- sum(flightCountsNew$noOfFlights)

# Calculate the percentage of flights for each airline and round to 2 decimal places
flightCountsNew <- flightCountsNew %>%
  dplyr::mutate(percentageOfFlights = round((noOfFlights / totalFlightsNew) * 100, 2))

# Add a row for the total
flightCountsNew <- flightCountsNew %>%
  dplyr::add_row(airlineName = "Total", noOfFlights = totalFlightsNew, percentageOfFlights = 100)

# Create the final table
airlineTableNew <- flightCountsNew %>%
  dplyr::select(`Airline Name` = airlineName, `No of Flights` = noOfFlights, `Percentage of Flights` = percentageOfFlights)

# Display the table using kable
TableAirlinesNew <-
  kable(airlineTableNew, 
        format = "pandoc", 
        caption = "Table 1b: Number of Flights by Airline (Top 4 and Other Airlines)")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
### Table 1a: Number of Flights by Airline

# Count the number of flights for each airline
flightCounts <- df %>%
  group_by(mktUniqueCarrier, airline) %>%
  summarise(noOfFlights = n(), .groups = 'drop') %>%
  arrange(desc(noOfFlights))

# Calculate the total number of flights
totalFlights <- sum(flightCounts$noOfFlights)

# Calculate the percentage of flights for each airline and round to 2 decimal places
flightCounts <- flightCounts %>%
  mutate(percentageOfFlights = round((noOfFlights / totalFlights) * 100, 2))

# Add a row for the total
flightCounts <- flightCounts %>%
  add_row(mktUniqueCarrier = "Total", airline = "Total", noOfFlights = totalFlights, percentageOfFlights = 100)

# Create the final table
airlineTable <- flightCounts %>%
  select(`IATA Code` = mktUniqueCarrier, Airline = airline, `No of Flights` = noOfFlights, `Percentage of Flights` = percentageOfFlights)

# Display the table using kable
TableFlightsByAirlines <-
  kable(airlineTable, 
        format = "pandoc", 
        caption = "Table 1a: Number of Flights by Airline")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# END READING AND PROCESSING DATA COLUMNS ###########
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############ BEGIN LongWeekend SETUP ###########
```

```{r echo=FALSE, warning=FALSE, message=FALSE}

######## Major US HOLIDAYS
# Define the holidays with their names and dates
holidays <- data.frame(
  NameOfHoliday = c("New Year's Day", "Martin Luther King Jr. Day", "Presidents' Day", "Memorial Day",
                    "Independence Day", "Labor Day", "Columbus Day", "Veterans Day", 
                    "Thanksgiving Day", "Christmas Day", "New Year's Eve"),
  DateOfHoliday = c("2023-01-01", "2023-01-16", "2023-02-20", "2023-05-29",
                    "2023-07-04", "2023-09-04", "2023-10-09", "2023-11-11",
                    "2023-11-23", "2023-12-25", "2023-12-31")
)

# Convert the DateOfHoliday to Date class
holidays$DateOfHoliday <- as.Date(holidays$DateOfHoliday)

# Add the day of the week for each holiday
holidays$DayOfWeek <- weekdays(holidays$DateOfHoliday)

# Display the table using kable
TableUSHolidays <-
  kable(holidays, 
        format = "pandoc", 
        caption = "Table 6: Major US Holidays in 2023")

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
##### Generate a list of major US holidays and the Long Weekends corresponding to them 

# Define the holidays and their dates
holidays <- data.frame(
  nameOfHoliday = c("New Year's Day", "Martin Luther King Jr. Day", "Presidents' Day", "Memorial Day",
                    "Independence Day", "Labor Day", "Columbus Day", "Veterans Day",
                    "Thanksgiving Day", "Christmas Day", "New Year's Eve"),
  dateOfHoliday = as.Date(c("2023-01-01", "2023-01-16", "2023-02-20", "2023-05-29",
                            "2023-07-04", "2023-09-04", "2023-10-09", "2023-11-11",
                            "2023-11-23", "2023-12-25", "2023-12-31"))
)

# Function to add specific adjacent days based on the day of the week
addAdjacentDays <- function(date) {
  c(date,
    date - 1,  # Day before
    date + 1,  # Day after
    if (weekdays(date) == "Friday") date + 2,  # Extending if Friday
    if (weekdays(date) == "Thursday") date + 3  # Extending if Thursday
  )
}

# Generate a list of dates for each holiday including the specific additional days
holidays$extendedDates <- lapply(holidays$dateOfHoliday, addAdjacentDays)

# Create an expanded dataframe that includes all extended dates tagged with their holiday
expandedDates <- do.call(rbind, lapply(seq_along(holidays$extendedDates), function(i) {
  data.frame(Date = as.Date(holidays$extendedDates[[i]]),
             nameOfHoliday = holidays$nameOfHoliday[i])
}))

# Remove duplicates and sort
expandedDates <- expandedDates %>%
  distinct() %>%
  arrange(Date)

# Calculate the differences to find consecutive dates
expandedDates <- expandedDates %>%
  mutate(NextDateDiff = lead(Date) - Date)

# Find long weekends based on consecutive dates
expandedDates$isPartOfLongWeekend <- expandedDates$NextDateDiff == 1 | lag(expandedDates$NextDateDiff) == 1

# Filter to get only the long weekend dates
longWeekendDates <- expandedDates %>%
  filter(isPartOfLongWeekend)

# Generate a summary table with holiday names and add weekdays
longWeekendDates <- longWeekendDates %>%
  mutate(DayOfWeek = weekdays(Date)) %>%
  select(Date, DayOfWeek, nameOfHoliday)

# Filter out dates not in 2023
longWeekendDates2023 <- longWeekendDates %>%
  filter(year(Date) == 2023)

# Generate a summary table with holiday names and add weekdays
longWeekendDates2023 <- longWeekendDates2023 %>%
  mutate(DayOfWeek = weekdays(Date)) %>%
  select(Date, DayOfWeek, nameOfHoliday)

# Display the long weekends only for 2023
TableLongWeekend <- 
  kable(longWeekendDates2023, 
        format = "pandoc", 
        caption = "Table 7: Long Weekends in the United States for 2023 with Corresponding Holidays")

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
##### Add a data column isLongWeekend to track if a flight date falls on a long weekend

# Ensure 'flDate' is of Date type
df$flDate <- as.Date(df$flDate)

# Check if each flight date is in the list of long weekend dates
df$isLongWeekend <- df$flDate %in% longWeekendDates2023$Date
# Now 'df' has an additional column 'isLongWeekend' that is TRUE if the flight occurs on a long weekend

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############ END LongWeekend SETUP ###########
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# BEGIN CREATING TABLES EXPLAINING DATA COLUMNS ###########

######## TIME PERIOD ########
# Table 3: Time Period Information
timeperiod <- data.frame(
  `Column Name` = c("year", "quarter", "month", "dayOfMonth", "dayOfWeek", "weekend", "flDate"),
  Description = c("Year", "Quarter (1-4)", "Month (Jan, Feb,..Dec)", "Day of Month (1,2,..31)", "Day of Week (Mon, Tue.. Sun)","Weekend / Weekday", "Flight Date (yyyy-mm-dd)")
)

TableTimeperiod <-
  kable(timeperiod, 
        format = "pandoc", 
        caption = "Table 3: Time Period Information")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Table: Flight Performance Metrics 
flightPerformanceMetrics <- data.frame(
  `Column Name` = c("crsDepTime", 
                    "depTime", 
                    "depTimeAMPM",  # Added AM/PM categorization for departure time
                    "depDelay", 
                    "depDelayNew", 
                    "depDel15", 
                    "taxiOut", 
                    "wheelsOff", 
                    "wheelsOn", 
                    "taxiIn", 
                    "crsArrTime", 
                    "arrTime", 
                    "arrTimeAMPM",  # Added AM/PM categorization for arrival time
                    "arrDelay", 
                    "arrDelayNew", 
                    "arrDel15", 
                    "cancelled", 
                    "cancellationCode", 
                    "diverted", 
                    "crsElapsedTime",
                    "actualElapsedTime", 
                    "airTime", 
                    "distance"),
  Description = c("Scheduled Departure Time", 
                  "Actual Departure Time",
                  "AM/PM Categorization of Departure Time",  # Description for depTimeAMPM
                  "Departure Delay in minutes, where (depDelay = depTime - crsDepTime)", 
                  "Departure Delay in minutes (zero for early departure)", 
                  "Departure Delay > 15 minutes (1=Yes, 0=No)", 
                  "Taxi Out Time in minutes, where (taxiOut = wheelsOff - depTime)", 
                  "Wheels Off Time", 
                  "Wheels On Time", 
                  "Taxi In Time, where (taxiIn = arrTime - wheelsOn)", 
                  "Scheduled Arrival Time", 
                  "Actual Arrival Time", 
                  "AM/PM Categorization of Arrival Time",  # Description for arrTimeAMPM
                  "Arrival Delay in minutes, where (arrDelay = arrTime - crsArrTime)", 
                  "Arrival Delay in minutes (zero for early arrival)", 
                  "Arrival Delay > 15 minutes (1=Yes)", 
                  "Cancelled Flight Indicator (1=Yes)", 
                  "Specifies The Reason For Cancellation", 
                  "Diverted Flight Indicator (1=Yes, 0=No)", 
                  "Scheduled Elapsed Time of Flight in minutes, where (crsElapsedTime = crsArrTime - crsDepTime)", 
                  "Actual Elapsed Time of Flight in minutes, where (actualElapsedTime = ArrTime - DepTime)", 
                  "Flight Time in minutes, where (airTime = wheelsOn - wheelsOff)", 
                  "Distance between airports in miles")
)

# Use kable to format the updated table
TableFlightPerformance <- 
  kable(flightPerformanceMetrics, 
        format = "pandoc", 
        caption = "Table 4: Flight Performance Metrics")

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Table: Causes of Delay
causeDelay <- data.frame(
  `Column Name` = c("carrierDelay", 
                    "weatherDelay", 
                    "nasDelay", 
                    "securityDelay", 
                    "lateAircraftDelay"),
  Description = c("Carrier Delay in minutes", 
                  "Weather Delay in minutes", 
                  "National Air System Delay in minutes", 
                  "Security Delay in minutes", 
                  "Late Aircraft Delay in minutes")
)

# Use kable to format the updated table
TableFlightDelayCauses <-
  kable(causeDelay, 
      format = "pandoc", 
      caption = "Table 5: Cause of Delay")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Airport Details
airportDetails <- data.frame(
  `Column Name` = c("originCityMarketId", 
                    "origin", 
                    "originCityName", 
                    "originStateAbr", 
                    "originStateNm", 
                    "destAirportId", 
                    "destCityMarketId", 
                    "dest", 
                    "destCityName", 
                    "destStateAbr", 
                    "destStateNm"),
  Description = c("Origin City Market ID", 
                  "Origin Airport", 
                  "Origin City Name", 
                  "Origin State Abbreviation", 
                  "Origin State Name", 
                  "Destination Airport ID", 
                  "Destination City Market ID", 
                  "Destination Airport", 
                  "Destination City Name", 
                  "Destination State Abbreviation", 
                  "Destination State Name")
)

# Use kable to format the updated table
TableAirports <-
  kable(airportDetails, 
        format = "pandoc", 
        caption = "Table 2a: Airport Details")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Generate a list of unique IATA codes of airports based on arrivals (dest)
uniqueIATACodes <- df %>%
  distinct(dest) %>%
  arrange(dest)

# Generate a comma-separated list of unique IATA codes
IATACodeList <- paste(uniqueIATACodes$dest, collapse = ", ")

# Create a table with the comma-separated list
uniqueIATACodesTable <- data.frame(
  `List of IATA Codes` = IATACodeList
)

# Use kable to format the table
TableUniqueIATACodes <-
  kable(uniqueIATACodesTable, 
        format = "pandoc", 
        caption = "Table 2b: Unique IATA Codes of Airports Based on Arrivals")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Busiest Airports in the US (based on external reference)

busiestAirports <- data.frame(
  IATACode = c("ATL", "DFW", "DEN", "LAX", "ORD", "JFK", "MCO", "LAS", 
                "CLT", "MIA", "SEA", "SFO", "EWR", "PHX", "IAH", "BOS"),
  Airport = c("Hartsfield–Jackson Atlanta International Airport",
              "Dallas Fort Worth International Airport",
              "Denver International Airport",
              "Los Angeles International Airport",
              "O'Hare International Airport",
              "John F. Kennedy International Airport",
              "Orlando International Airport",
              "Harry Reid International Airport",
              "Charlotte Douglas International Airport",
              "Miami International Airport",
              "Seattle–Tacoma International Airport",
              "San Francisco International Airport",
              "Newark Liberty International Airport",
              "Phoenix Sky Harbor International Airport",
              "George Bush Intercontinental Airport",
              "Logan International Airport"),
  City = c("Atlanta", "Dallas–Fort Worth", "Denver", "Los Angeles", 
           "Chicago", "Queens, New York", "Orlando", "Las Vegas", 
           "Charlotte", "Miami-Dade County", "SeaTac", "San Mateo County", 
           "Newark", "Phoenix", "Houston", "Boston"),
  State = c("Georgia", "Texas", "Colorado", "California", "Illinois", 
            "New York", "Florida", "Nevada", "North Carolina", "Florida", 
            "Washington", "California", "New Jersey", "Arizona", 
            "Texas", "Massachusetts"),
  PassengerTraffic = c(104653451, 81755538, 77837917, 75050875, 73894226, 
                        62464331, 57735726, 57666456, 53445770, 52340934, 
                        50877260, 50196094, 49084774, 48654432, 46168662, 
                        40861658)
)

# Use kable to format the table
TableBusiestAirports <-
  kable(busiestAirports, 
        format = "pandoc", 
        caption = "Table 2c: 16 Busiest Airports in the US")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Busiest Airports in the US (based on our data, counting Number of Arriving Flights at each airport in our data)

# Create a dataframe for airport names and IATA codes
airportNames <- data.frame(
  dest = c("ATL", "DFW", "DEN", "LAX", "ORD", "JFK", "MCO", "LAS", 
           "CLT", "MIA", "SEA", "SFO", "EWR", "PHX", "IAH", "BOS", 
           "LGA", "DCA"),
  airportName = c("Hartsfield–Jackson Atlanta International Airport",
                  "Dallas Fort Worth International Airport",
                  "Denver International Airport",
                  "Los Angeles International Airport",
                  "O'Hare International Airport",
                  "John F. Kennedy International Airport",
                  "Orlando International Airport",
                  "Harry Reid International Airport",
                  "Charlotte Douglas International Airport",
                  "Miami International Airport",
                  "Seattle–Tacoma International Airport",
                  "San Francisco International Airport",
                  "Newark Liberty International Airport",
                  "Phoenix Sky Harbor International Airport",
                  "George Bush Intercontinental Airport",
                  "Logan International Airport",
                  "LaGuardia Airport",
                  "Ronald Reagan Washington National Airport")
)

# Frequency count of the IATA codes in the destination column
top16Airports <- df %>%
  group_by(dest) %>%
  summarise(flightCount = n()) %>%
  arrange(desc(flightCount)) %>%
  top_n(16, flightCount)

# Calculate the total number of flights
totalFlights <- sum(df$dest != "")

# Calculate the percentage of the entire sample
top16Airports <- top16Airports %>%
  mutate(percentageOfTotal = round((flightCount / totalFlights) * 100, 2))

# Merge top16Airports with airportNames to get the airport names
top16Airports <- top16Airports %>%
  left_join(airportNames, by = "dest")

# Create the final table
airportTable <- top16Airports %>%
  select(`Destination IATA Code` = dest, `Airport Name` = airportName, `Number of Flights` = flightCount, `Percentage of Total` = percentageOfTotal)

# Use kable to format the table
TableTop16Airports <-
  kable(airportTable, 
        format = "pandoc", 
        caption = "Table 2d: Top 16 Busiest Airports by Number of Arriving Flights")

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
#  Add new columns originBusiest and destBusiest to df, checking if the origin and dest columns contain the IATA codes of the 16 busiest airports. 

library(dplyr)
# Define the IATA codes for the 16 busiest airports
busiestAirportsIATA <- c("ATL", "DFW", "DEN", "LAX", "ORD", "JFK", "MCO", "LAS", 
                         "CLT", "MIA", "SEA", "SFO", "EWR", "PHX", "IAH", "BOS")

# Add new columns to the dataframe to track if the origin or destination is one of the busiest airports
df <- df %>%
  mutate(
    originBusiest = if_else(origin %in% busiestAirportsIATA, 1, 0),
    destBusiest = if_else(dest %in% busiestAirportsIATA, 1, 0)
  )

```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Table: Summary of Flights Mapping to Busiest Airports 
# Count flights where Only Origin Airport, Only Dest Airport, both or neither airports are one of the Busiest

# Define the conditions for each category
onlyOriginBusiest <- df$originBusiest == 1 & df$destBusiest == 0
onlyDestBusiest <- df$originBusiest == 0 & df$destBusiest == 1
bothBusiest <- df$originBusiest == 1 & df$destBusiest == 1
neitherBusiest <- df$originBusiest == 0 & df$destBusiest == 0

# Count the number of flights for each category
countOnlyOriginBusiest <- sum(onlyOriginBusiest)
countOnlyDestBusiest <- sum(onlyDestBusiest)
countBothBusiest <- sum(bothBusiest)
countNeitherBusiest <- sum(neitherBusiest)

# Calculate the total number of flights
totalFlights <- nrow(df)

# Calculate the percentage of total flights for each category
percentOnlyOriginBusiest <- round((countOnlyOriginBusiest / totalFlights) * 100, 2)
percentOnlyDestBusiest <- round((countOnlyDestBusiest / totalFlights) * 100, 2)
percentBothBusiest <- round((countBothBusiest / totalFlights) * 100, 2)
percentNeitherBusiest <- round((countNeitherBusiest / totalFlights) * 100, 2)

# Create a data frame to summarize the results
busiestSummary <- data.frame(
  Category = c("Only Origin Airport is one of the Busiest", "Only Dest Airport is one of the Busiest", "Both Origin & Dest Airports are one of the Busiest", "Neither Origin nor Dest Airports are one of the Busiest", "All Flights"),
  CountFlights = c(countOnlyOriginBusiest, countOnlyDestBusiest, countBothBusiest, countNeitherBusiest, totalFlights),
  PercentageFlights = c(percentOnlyOriginBusiest, percentOnlyDestBusiest, percentBothBusiest, percentNeitherBusiest, 100.00)
)

# Display the table using kable
TableBusiestSummary <- kable(busiestSummary, 
                             format = "pandoc", 
                             caption = "Table 2e: Summary of Flights Mapping to Busiest Airports")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Carrier Information
carrierInformation <- data.frame(
  `Column Name` = c("mktUniqueCarrier"),
  Description = c("Marketing Carrier Unique Code")
)

# Use kable to format the updated table
TableAirlines <-
kable(carrierInformation, 
      format = "pandoc", 
      caption = "Table 5: Carrier Information")
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# END CREATING TABLES EXPLAINING DATA COLUMNS ###########
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# BEGIN WRITING ###########
# Hint: Do All Data Processing and Analysis Above This Line, as far as possible
# Hint: Save all analysis output (e.g. Tables) in variables Above This Line
# Hint: Use the saved variables and Focus on Writing and Discussion Below This Line
```

# Review of Flight Delay Data

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# BEGIN DESCRIBING THE DATA AND DATA COLUMNS ###########
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Calculate the total number of flights
totalFlights <- nrow(df)
```

## Data Description

This dataset describes the `r totalFlights` domestic flights that took off in the United States during 2023. It encompasses detailed information on flight delays in the United States during the year 2023.

The data is organized across various dimensions, including time periods, flight performance metrics, causes of delay, airport details, and carrier information. Each dimension provides a unique perspective on the factors influencing flight delays and overall flight operations.

### Flights and Airlines

The *mktUniqueCarrier* or Marketing Carrier Unique Code, represents the marketing carrier, which is the airline responsible for selling the flight. **Table 1a** lists the 10 unique Airlines -- American Airlines (AA), Alaska Airlines (AS), JetBlue Airways (B6), Delta Air Lines (DL), Frontier Airlines (F9), Allegiant Air (G4), Hawaiian Airlines (HA), Spirit Airlines (NK), United Airlines (UA), and Southwest Airlines (WN).

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## TableFlightsByAirlines ########
TableFlightsByAirlines
```

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Calculate the sum of the market share of the top 4 airlines
top4MarketShare <- sum(flightCounts$percentageOfFlights[1:4])
```

The top 4 airlines by market share are American Airlines (AA), Delta Air Lines (DL), Southwest Airlines (WN) and United Airlines (UA), jointly accounting for `r top4MarketShare`% of market share.

**Table 1b** provides a breakdown of the flights operated by the top 4 airline in 2023, merging Other Airlines.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## TableAirlinesNew ########
TableAirlinesNew
```

### Airports

#### Origin and Destination Airports

**Table 2a** provides details about the origin and destination airports involved in the flight data.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Origin and Destination Airports ########
TableAirports
```

The *originCityMarketId* and *destCityMarketId* columns represent the unique market identifiers for the origin and destination cities, respectively. The *origin* and *dest* columns specify the airport codes for the origin and destination airports. The *originCityName* and *destCityName* columns provide the full names of these cities. Additionally, the *originStateAbr* and *destStateAbr* columns indicate the state abbreviations, while *originStateNm* and *destStateNm* give the full state names. These columns collectively provide comprehensive information about the origin and destination airports for each flight.

#### Busiest Airports

**Table 2b** lists the IATA codes of all the `r nrow(uniqueIATACodes)` airports in the data:

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Display Table 2b: Unique IATA Codes of Airports Based on Arrivals
TableUniqueIATACodes
```

**Table 2c** provides a list of the 16 busiest airports in the US. Source: "2023 Airport Traffic Report" (PDF). Port Authority of New York and New Jersey. April 2024. p. 32.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Table 2c: 16 Busiest Airports in the US ########
TableBusiestAirports
```

**Table 2d** provides a list of the 16 busiest airports in the US, based on number of Arriving Flights in our data.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Table 2d: 16 Busiest Airports in the US, based on number of Arriving Flights ########
TableTop16Airports
```

**Table 2e** summarizes the distribution of flights based on whether the origin and/or destination airports are among the 16 busiest airports.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Table 2e:  Summary of Flights Mapping to Busiest Airports ########
TableBusiestSummary
```

**Table 2e** shows that `r busiestSummary$CountFlights[1]` flights (`r busiestSummary$PercentageFlights[1]`%) originate from one of the busiest airports, `r busiestSummary$CountFlights[2]` flights (`r busiestSummary$PercentageFlights[2]`%) have one of the busiest airports as their destination, `r busiestSummary$CountFlights[3]` flights (`r busiestSummary$PercentageFlights[3]`%) have both origin and destination among the busiest, and `r busiestSummary$CountFlights[4]` flights (`r busiestSummary$PercentageFlights[4]`%) involve neither of the busiest airports.

### Time Period

**Table 3** provides details about various time-related aspects of the flight data.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## TIME PERIOD ########
TableTimeperiod
```

The *year* column indicates the calendar year of the flight, while the *quarter* divides the year into four parts (1-4). The *month* column specifies the month in which the flight occurred, ranging from January to December. The *dayOfMonth* indicates the specific day of the month (1-31), and the *dayOfWeek* categorizes the flight by the day of the week (Monday to Sunday). The *weekend* column classifies the flight as either occurring on a weekday or a weekend. Lastly, the *flDate* provides the precise flight date in the format yyyy-mm-dd, encapsulating all essential time period information.

### Flight Performance Metrics

**Table 4** provides details about different Flight Performance Metrics.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Flight Performance Metrics ########
TableFlightPerformance
```

The *crsDepTime* represents the scheduled departure time, indicating when the flight is supposed to leave the gate according to the airline’s timetable. However, the *depTime* is the actual departure time, which marks when the flight actually departs from the gate. The *depTimeAMPM* categorizes this actual departure time into either AM or PM, helping to identify whether the departure occurred in the morning or afternoon/evening.

The *depDelay* is a crucial metric that calculates the departure delay in minutes by subtracting the scheduled departure time (*crsDepTime*) from the actual departure time (*depTime*). If the result is positive, it indicates a delay, whereas a negative value shows the flight departed earlier than scheduled. To focus solely on delays, the *depDelayNew* column adjusts this value by setting any early departure delays to zero. This column thus represents the departure delay in minutes, ignoring early departures.

For a more specific delay threshold, the *depDel15* column is used. It is a binary indicator showing whether the departure delay was greater than 15 minutes, with a value of 1 indicating a delay over 15 minutes and 0 otherwise. This helps in identifying significant delays.

Once the aircraft pushes back from the gate, it undergoes the taxi-out phase, which is captured by the *taxiOut* time. This is the duration in minutes from the time the aircraft leaves the gate until it takes off (wheels-off). The exact time the aircraft takes off is recorded as *wheelsOff*. Conversely, the time the aircraft lands is noted as *wheelsOn*, and the subsequent taxi-in phase, from landing to reaching the gate, is recorded as *taxiIn* time.

On the arrival side, the *crsArrTime* indicates the scheduled arrival time, while the *arrTime* shows the actual arrival time. The *arrTimeAMPM* column categorizes the actual arrival time into AM or PM. The difference between the actual and scheduled arrival times is captured by the *arrDelay*, reflecting the arrival delay in minutes. Similar to the departure delay, *arrDelayNew* sets early arrivals to zero, providing a focused view of arrival delays. Additionally, *arrDel15* serves as a binary indicator of whether the arrival delay exceeded 15 minutes.

Furthermore, the *crsElapsedTime* represents the scheduled elapsed time of the flight, calculated as the difference between the scheduled arrival time (*crsArrTime*) and the scheduled departure time (*crsDepTime*). In contrast, the *actualElapsedTime* captures the actual elapsed time of the flight from departure to arrival. The *airTime* isolates the actual time spent flying by subtracting the taxi-out and taxi-in times from the actual elapsed time.

The *actualElapsedTime* is the total time taken for the flight from the moment it departs the gate until it arrives at the destination gate. This includes all phases of the flight: the time spent in the air, as well as the time spent taxiing on the ground at both the departure and arrival airports. Specifically, *actualElapsedTime* can be broken down into three components: *airTime*, *taxiIn*, and *taxiOut*.

The *airTime* represents the duration of the flight while it is airborne, from takeoff (wheels-off) to landing (wheels-on). The *taxiOut* time covers the period from the gate departure to the actual takeoff, and the *taxiIn* time spans from the landing to when the aircraft reaches the arrival gate. Together, these components sum up to the *actualElapsedTime*, providing a comprehensive measure of the total journey time in minutes: *actualElapsedTime = airTime + taxiIn + taxiOut*

Finally, the *distance* column denotes the distance between the origin and destination airports in miles, providing a measure of the flight’s journey length.

### Flight Delays

```{r echo=FALSE, warning=FALSE, message=FALSE}
# Calculate the total number of flights
totalFlights <- nrow(df)

# Calculate the number of flights that arrived more than 15 minutes late
flightsArrivedLate <- sum(df$arrDel15 == 1, na.rm = TRUE)

# Calculate the percentage of flights that arrived more than 15 minutes late
percentageArrivedLate <- (flightsArrivedLate / totalFlights) * 100
```

It includes a total of `r totalFlights` flights. Out of these, `r flightsArrivedLate` flights arrived more than 15 minutes late, representing approximately `r round(percentageArrivedLate, 2)`% of the total flights. This statistic highlights the prevalence of significant delays within the dataset and underscores the importance of analyzing the factors contributing to these delays.

#### Causes of Flight Delay

**Table 5** on causes of flight delay provides insights into various reasons for flight delays, measured in minutes.

```{r echo=FALSE, warning=FALSE, message=FALSE}
######## Flight Delay Causes ########
TableFlightDelayCauses
```

The *carrierDelay* column accounts for delays caused by the airline, such as maintenance issues or crew problems. The *weatherDelay* captures delays due to adverse weather conditions that impact flight schedules. The *nasDelay* reflects delays within the National Air System, including heavy traffic volume, air traffic control, and other non-weather-related factors. The *securityDelay* records delays caused by security measures or breaches. Lastly, the *lateAircraftDelay* measures delays caused by the late arrival of the aircraft from a previous flight. These columns collectively provide a detailed breakdown of the different factors contributing to flight delays.

```{r echo=FALSE, warning=FALSE, message=FALSE}
############# END WRITING ###########
# Hint: Do Not Mixup WRITING with ANALYSIS. Do not try to do both together. 
```

\newpage

# Appendices

## Appendix 1 -- Unused Data Columns

```{r  echo=FALSE, warning=FALSE, message=FALSE}

# Remaining Unused Data Columns
remainingUnusedDataColumns <- data.frame(
  `Column Name` = c("depDelayGroup", 
                    "depTimeBlk", 
                    "arrDelayGroup", 
                    "arrTimeBlk", 
                    "flights", 
                    "distanceGroup",
                    "opUniqueCarrier",
                    "tailNum",
                    "mktCarrierFlNum"),
  Description = c("Grouping of Departure Delay Intervals", 
                  "Scheduled Departure Time Block", 
                  "Grouping of Arrival Delay Intervals", 
                  "Scheduled Arrival Time Block", 
                  "Number of Flights (usually 1)", 
                  "Distance Group (distance intervals)",
                  "Operating Carrier Unique Code",
                  "Tail Number of the Aircraft",
                  "Marketing Carrier Flight Number")
)

# Use kable to format the updated table
kable(remainingUnusedDataColumns, 
      format = "pandoc", 
      caption = "Appendix 1: Table A1: Remaining Unused Data Columns")

```

The *mktUniqueCarrier* or Marketing Carrier Unique Code, represents the marketing carrier, which is the airline responsible for selling the flight. This code may differ from the operating carrier, which is the Airline that actually operates the flight. The marketing carrier manages the scheduling and ticket sales for the flight. For instance, if you book a flight through United Airlines (UA), UA is the marketing carrier, even if the flight is operated by another airline.

The *opUniqueCarrier* or Operating Carrier Unique Code, represents the operating carrier, which is the airline that physically operates the flight. This can be different from the marketing carrier, especially in cases of code-share agreements, where one airline markets the flight, but another airline operates it. For example, you might book a flight through United Airlines (UA), but the flight is operated by SkyWest Airlines (OO).

The *tailNum* or Tail Number of the Aircraft, is the unique identifier of the aircraft, often referred to as the registration number. This number is typically painted on the tail of the aircraft and is used to track the aircraft’s maintenance and operational history. For example, a tail number might look like "N12345" for an aircraft registered in the United States.

The *mktCarrierFlNum* or Marketing Carrier Flight Number, represents the flight number assigned by the marketing carrier. This number is used to identify a specific flight in the airline’s schedule and is typically a combination of the carrier code and a numeric flight number. For instance, a flight marketed by United Airlines with flight number 123 would be referred to as UA123.
